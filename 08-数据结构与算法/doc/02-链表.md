# 一、链表
## 1.1 单链表
[单链表示例代码](../src/_02链表/_01单链表/SingleLinkedList.java)

> 面试题：   
> 1）单链表反转   
> 定义新链表 reverse，从头遍历原链表，得到一个元素就向 反转链表 的头部添加该元素。
> 
> 2）倒序打印单链表
> 方法一：倒序遍历
> 方法二：将结点正序入栈，然后出栈打印
> 
> 

## 1.2 双向链表

> 单向链表的缺点分析: 
> 1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 
> 2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到 temp,temp 是待删除节点的前一个节点. 
> 

[双向链表示例代码](../src/_02链表/_02双向链表/DoubleLinkedList.java)   
主要变动：   
1. indexOf(Object o)：    
   - 调整为双向遍历，牺牲空间换取时间   
2. getNode(int index)：   
   - 调整为分情况正向遍历和反向遍历
3. clear()：   
   - 需要将head和tail同时置空
4. add(E element)   


## 1.3 单向环形链表
### 1）Josephu（约瑟夫）问题
> 设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。
> 
```text
约瑟夫测试用例：
8 人，从第 1 个人开始报数，报数至 2
10 人，从第 1 个人开始报数，报数至 3
详细案例见示例代码hosephu(int start, int m)注释
```


和单链表的区别：   
1. add(E element)：   
   - 追加元素时，要保证每一时刻的最后一个元素的next指针指向head结点
2. remove(int index)：   
   - 删除最后一个结点时，要注意让新结点的next指向head
3. toString()：   
   - 因为toString方法需要遍历整个链表，然而该链表为循环链表，没有任何一个结点为null，所以要将之前的 `temp.next != null` 改为 `Objects.equals(temp.next, head)`

[单向循环链表示例代码(约瑟夫方法在最后)](../src/_02链表/_03单向环形链表/CircleSingleLinkedList.java)

